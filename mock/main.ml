(** DEC Executable OCaml Implementation *)

open Big_int
open Char
open Dec
open Driver_jr

let big_int_of_pos n =
  let iter_op op n a =
    let rec iter n a = match n with
      | XI p -> op a (iter p (op a a))
      | XO p -> iter p (op a a)
      | XH -> a in
    iter n a in
  iter_op add_big_int n unit_big_int

let big_int_of_z i = match i with
  | Z0 -> zero_big_int
  | Zpos p -> big_int_of_pos p
  | Zneg p -> minus_big_int (big_int_of_pos p)

let rec pos_of_big_int i = match quomod_big_int i (big_int_of_int 2) with
  | (q, m) -> match sign_big_int q with
    | 0 -> begin match sign_big_int m with
      | 0 -> raise (Failure "what the dick")
      | 1 -> XH
      | _ -> raise (Failure "what the shit")
      end
    | 1 -> begin match sign_big_int m with
      | 0 -> XO (pos_of_big_int q)
      | 1 -> XI (pos_of_big_int q)
      | _ -> raise (Failure "what the fuck")
      end
    | _ -> raise (Failure "what the ass")

let z_of_big_int i = match sign_big_int i with
  | 0 -> Z0
  | 1 -> Zpos (pos_of_big_int i)
  | -1 -> Zneg (pos_of_big_int i)
  | _ -> raise (Failure "what the cunt")

(** We need [Obj.magic] to work with code generated by coercions. *)
let () =
  print_endline "main";
  print_endline (string_of_big_int (big_int_of_z
      (Obj.magic (DEC.monkey_saddle
          (z_of_big_int (big_int_of_int 42))
          (z_of_big_int (big_int_of_int 13))))));
  print_endline (string_of_int (JR.monkey_saddle_unsafe 42 13));
  print_endline "THE GRAND FINALE (should print 0, 58, 206)";
  Array.iter print_endline (Array.map string_of_int (Array.map code (JR.monkey_saddle
      (Array.map chr [|0; 42|])
      (Array.map chr [|0; 13|]))))
