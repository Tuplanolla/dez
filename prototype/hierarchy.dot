digraph hierarchy {
  // Ideally, we would use the following alphabetical list.

  /*
  Does [label = "\N\nOperational Classes"]
  Entails [label = "\N\nOperational Class Notations"]
  Gives [label = "\N\nOperational Definitions"]
  Has [label = "\N\nOperational Definition Notations"]
  Is [label = "\N\nPredicative Classes"]
  Justifies [label = "\N\nPredicative Class Notations"]
  Provides [label = "\N\nPredicative Definitions"]
  Supports [label = "\N\nPredicative Definition Notations"]
  */

  // However, that would require giving up
  // "has" for operational classes or "is" for predicative classes,
  // which we do not want to do.
  // Thus, we would rather use the following list of alphabetical pairs.

  /*
  Has [label = "\N\nOperational Classes"]
  a [label = "\N\nOperational Class Notations"]
  b [label = "\N\nOperational Definitions"]
  c [label = "\N\nOperational Definition Notations"]
  Is [label = "\N\nPredicative Classes"]
  d [label = "\N\nPredicative Class Notations"]
  e [label = "\N\nPredicative Definitions"]
  f [label = "\N\nPredicative Definition Notations"]
  */

  // Let us try to solve this lattice problem.

  /*
  constraints: H < a, a < b, b < c, I < d, d < e, e < f,
               H < I, a < d, b < e, c < f,
               I <> a, a <> b, b <> c, c <> d, d <> e, e <> f
  derived: J <= a, K <= b, L <= c, K <= d, L <= e, O <= f,
           a <= W, b <= X, c <= Y, d <= X, e <= Y, f <= Z
  simplified: J <= a <= W, K <= b <= X, L <= c <= Y,
              K <= d <= X, L <= e <= Y, O <= f <= Z
  combined: J <= a <= W, a < min b d,
            K <= b <= X, b < min c e,
            L <= c <= Y, c < f, K <= d <= X, d < e,
            L <= e <= Y, e < f, O <= f <= Z
  vague: a "is like gives", b "is like implies", c "is like gives",
         d "is like gives", e "is like implies", f "is like gives"
  proposed: a = J(ustifies), b = M(anifests), c = O(ffers),
            d = P(rovides), e = S(upports), f = Y(ields)
  */

  // Well, perhaps mnemonic names would work better.

  OC [label = "Has\nOperational Classes"]
  OCN [label = "ShouldHave\nOperational Class Notations"]
  OD [label = "Offers\nOperational Definitions"]
  ODN [label = "ShouldOffer\nOperational Definition Notations"]
  PC [label = "Is\nPredicative Classes"]
  PCN [label = "ShouldBe\nPredicative Class Notations"]
  PD [label = "Provides\nPredicative Definitions"]
  PDN [label = "ShouldProvide\nPredicative Definition Notations"]

  // # Loops

  OC -> OC
  OCN -> OCN
  OD -> OD
  ODN -> ODN
  PC -> PC
  PCN -> PCN
  PD -> PD
  PDN -> PDN

  // # Paths

  OC -> OCN
  OCN -> OD
  OD -> ODN
  ODN -> PC
  PC -> PCN
  PCN -> PD
  PD -> PDN

  // # Cycles

  OCN -> OC
  ODN -> OD
  PCN -> PC
  PDN -> PD
}
