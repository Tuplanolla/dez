(** * Initialization for the Equations plugin. *)

From Coq Require Import
  Lists.List.
From Equations Require Export
  Equations.
From Maniunfold Require Export
  Init.

(** We mark equations transparent,
    because it is sometimes convenient
    to reduce them with [cbv] while exploring things. *)

Global Set Equations Transparent.

Import ListNotations.

Local Open Scope bool_scope.

(** This incomplete collection of corollaries
    would be generated by Equations. *)

Corollary Spr1_equation_1 (A : Type) (P : A -> SProp) (a : A) (b : P a) :
  Spr1 (Sexists P a b) = a.
Proof. reflexivity. Qed.

Hint Rewrite @Spr1_equation_1 : Spr1.

(** TODO Why does this fail? *)

Corollary Spr2_equation_1 (A : Type) (P : A -> SProp) (a : A) (b : P a) :
  Spr2 (Sexists P a b) = b.
Proof. reflexivity. Fail Qed. Abort.

Fail Hint Rewrite @Spr2_equation_1 : Spr2.

Corollary andb_equation_1 (b1 b2 : bool) :
  true && b2 = b2.
Proof. reflexivity. Qed.

Corollary andb_equation_2 (b1 b2 : bool) :
  false && b2 = false.
Proof. reflexivity. Qed.

Hint Rewrite @andb_equation_1 @andb_equation_2 : andb.

Corollary orb_equation_1 (b1 b2 : bool) :
  true || b2 = true.
Proof. reflexivity. Qed.

Corollary orb_equation_2 (b1 b2 : bool) :
  false || b2 = b2.
Proof. reflexivity. Qed.

Hint Rewrite @orb_equation_1 @orb_equation_2 : orb.

Corollary implb_equation_1 (b1 b2 : bool) :
  implb true b2 = b2.
Proof. reflexivity. Qed.

Corollary implb_equation_2 (b1 b2 : bool) :
  implb false b2 = true.
Proof. reflexivity. Qed.

Hint Rewrite @implb_equation_1 @implb_equation_2 : implb.

Corollary xorb_equation_1 (b1 b2 : bool) :
  xorb true true = false.
Proof. reflexivity. Qed.

Corollary xorb_equation_2 (b1 b2 : bool) :
  xorb true false = true.
Proof. reflexivity. Qed.

Corollary xorb_equation_3 (b1 b2 : bool) :
  xorb false true = true.
Proof. reflexivity. Qed.

Corollary xorb_equation_4 (b1 b2 : bool) :
  xorb false false = false.
Proof. reflexivity. Qed.

Hint Rewrite @xorb_equation_1 @xorb_equation_2
  @xorb_equation_3 @xorb_equation_4 : xorb.

Corollary negb_equation_1 (b : bool) :
  negb true = false.
Proof. reflexivity. Qed.

Corollary negb_equation_2 (b : bool) :
  negb false = true.
Proof. reflexivity. Qed.

Hint Rewrite @negb_equation_1 @negb_equation_2 : negb.

Corollary is_true_equation_1 (b : bool) :
  is_true b = (b = true).
Proof. reflexivity. Qed.

Hint Rewrite @is_true_equation_1 : is_true.

Corollary option_map_equation_1 (A B : Type) (f : A -> B) (a : A) :
  option_map f (Some a) = Some (f a).
Proof. reflexivity. Qed.

Corollary option_map_equation_2 (A B : Type) (f : A -> B) :
  option_map f None = None.
Proof. reflexivity. Qed.

Hint Rewrite @option_map_equation_1 @option_map_equation_2 : option_map.

Corollary fst_equation_1 (A B : Type) (x : A) (y : B) : fst (x, y) = x.
Proof. reflexivity. Qed.

Hint Rewrite @fst_equation_1 : fst.

Corollary snd_equation_1 (A B : Type) (x : A) (y : B) : snd (x, y) = y.
Proof. reflexivity. Qed.

Hint Rewrite @snd_equation_1 : snd.

Corollary prod_curry_equation_1 (A B C : Type)
  (f : A * B -> C) (a : A) (b : B) :
  prod_curry f a b = f (a, b).
Proof. reflexivity. Qed.

Hint Rewrite @prod_curry_equation_1 : prod_curry.

Corollary prod_uncurry_equation_1 (A B C : Type)
  (f : A -> B -> C) (a : A) (b : B) :
  prod_uncurry f (a, b) = f a b.
Proof. reflexivity. Qed.

Hint Rewrite @prod_uncurry_equation_1 : prod_uncurry.

Corollary length_equation_1 (A : Type) :
  length (A := A) [] = 0.
Proof. reflexivity. Qed.

Corollary length_equation_2 (A : Type) (a : A) (l' : list A) :
  length (a :: l') = S (length l').
Proof. reflexivity. Qed.

Hint Rewrite @length_equation_1 @length_equation_2 : length.

Corollary app_equation_1 (A : Type) (m : list A) :
  [] ++ m = m.
Proof. reflexivity. Qed.

Corollary app_equation_2 (A : Type) (a : A) (l1 m : list A) :
  (a :: l1) ++ m = a :: (l1 ++ m).
Proof. reflexivity. Qed.

Hint Rewrite @app_equation_1 @app_equation_2 : app.

Corollary ID_equation_1 : ID = forall A : Type, A -> A.
Proof. reflexivity. Qed.

Hint Rewrite @ID_equation_1 : ID.

Corollary id_equation_1 (A : Type) (x : A) : id x = x.
Proof. reflexivity. Qed.

(** TODO Why does this fail? *)

(* Hint Rewrite @id_equation_1 : id. *)

Corollary IDProp_equation_1 : IDProp = forall A : Prop, A -> A.
Proof. reflexivity. Qed.

Hint Rewrite @IDProp_equation_1 : IDProp.

Corollary idProp_equation_1 (A : Prop) (x : A) : idProp x = x.
Proof. reflexivity. Qed.

Hint Rewrite @idProp_equation_1 : idProp.

Corollary proj1_sig_equation_1 (A : Type) (P : A -> Prop) (a : A) (b : P a) :
  proj1_sig (exist P a b) = a.
Proof. reflexivity. Qed.

Hint Rewrite @proj1_sig_equation_1 : proj1_sig.

Corollary proj2_sig_equation_1 (A : Type) (P : A -> Prop) (a : A) (b : P a) :
  proj2_sig (exist P a b) = b.
Proof. reflexivity. Qed.

Hint Rewrite @proj2_sig_equation_1 : proj2_sig.

Corollary projT1_equation_1 (A : Type) (P : A -> Type) (a : A) (b : P a) :
  projT1 (existT P a b) = a.
Proof. reflexivity. Qed.

Hint Rewrite @projT1_equation_1 : projT1.

Corollary projT2_equation_1 (A : Type) (P : A -> Type) (a : A) (b : P a) :
  projT2 (existT P a b) = b.
Proof. reflexivity. Qed.

Hint Rewrite @projT2_equation_1 : projT2.

Corollary sig_of_sigT_equation_1 (A : Type) (P : A -> Prop) (a : A) (b : P a) :
  sig_of_sigT (existT P a b) = exist P a b.
Proof. reflexivity. Qed.

Hint Rewrite @sig_of_sigT_equation_1 : sig_of_sigT.

Corollary sigT_of_sig_equation_1 (A : Type) (P : A -> Prop) (a : A) (b : P a) :
  sigT_of_sig (exist P a b) = existT P a b.
Proof. reflexivity. Qed.

Hint Rewrite @sigT_of_sig_equation_1 : sig_of_sig.

Corollary compose_equation_1 (A B C : Type)
  (g : B -> C) (f : A -> B) (x : A) : (g o f) x = g (f x).
Proof. reflexivity. Qed.

Hint Rewrite @compose_equation_1 : compose.

Corollary arrow_equation_1 (A B : Type) : arrow A B = (A -> B).
Proof. reflexivity. Qed.

Hint Rewrite @arrow_equation_1 : arrow.

Corollary impl_equation_1 (A B : Prop) : impl A B = (A -> B).
Proof. reflexivity. Qed.

Hint Rewrite @impl_equation_1 : impl.

Corollary const_equation_1 (A B : Type) (a : A) (b : B) : const a b = a.
Proof. reflexivity. Qed.

Hint Rewrite @const_equation_1 : const.

Corollary flip_equation_1 (A B C : Type) (f : A -> B -> C) (x : B) (y : A) :
  flip f x y = f y x.
Proof. reflexivity. Qed.

Hint Rewrite @flip_equation_1 : flip.

Corollary apply_equation_1 (A B : Type) (f : A -> B) (x : A) :
  apply f x = f x.
Proof. reflexivity. Qed.

Hint Rewrite @apply_equation_1 : apply.

Corollary prod_curry_dep_equation_1 (A B : Type) (P : A -> B -> Type)
  (f : forall x : A * B, P (fst x) (snd x)) (a : A) (b : B) :
  prod_curry_dep f a b = f (a, b).
Proof. reflexivity. Qed.

Hint Rewrite @prod_curry_dep_equation_1 : prod_curry_dep.

Corollary prod_uncurry_dep_equation_1 (A B : Type) (P : A -> B -> Type)
  (f : forall (a : A) (b : B), P a b) (a : A) (b : B) :
  prod_uncurry_dep f (a, b) = f a b.
Proof. reflexivity. Qed.

Hint Rewrite @prod_uncurry_dep_equation_1 : prod_uncurry_dep.

Corollary sig_curry_equation_1 (A : Type) (P : A -> Prop) (B : Type)
  (f : {a : A | P a} -> B) (a : A) (b : P a) :
  sig_curry f a b = f (exist P a b).
Proof. reflexivity. Qed.

Hint Rewrite @sig_curry_equation_1 : sig_curry.

Corollary sig_uncurry_equation_1 (A : Type) (P : A -> Prop) (B : Type)
  (f : forall a : A, P a -> B) (a : A) (b : P a) :
  sig_uncurry f (exist P a b) = f a b.
Proof. reflexivity. Qed.

Hint Rewrite @sig_uncurry_equation_1 : sig_uncurry.

Corollary sig_curry_dep_equation_1
  (A : Type) (P : A -> Prop) (Q : forall a : A, P a -> Type)
  (f : forall x : {a : A | P a}, Q (proj1_sig x) (proj2_sig x))
  (a : A) (b : P a) : sig_curry_dep f a b = f (exist P a b).
Proof. reflexivity. Qed.

Hint Rewrite @sig_curry_dep_equation_1 : sig_curry_dep.

Corollary sig_uncurry_dep_equation_1
  (A : Type) (P : A -> Prop) (Q : forall a : A, P a -> Type)
  (f : forall (a : A) (b : P a), Q a b) (a : A) (b : P a) :
  sig_uncurry_dep f (exist P a b) = f a b.
Proof. reflexivity. Qed.

Hint Rewrite @sig_uncurry_dep_equation_1 : sig_uncurry_dep.

Corollary sigT_curry_equation_1 (A : Type) (P : A -> Type) (B : Type)
  (f : {a : A & P a} -> B) (a : A) (b : P a) :
  sigT_curry f a b = f (existT P a b).
Proof. reflexivity. Qed.

Hint Rewrite @sigT_curry_equation_1 : sigT_curry.

Corollary sigT_uncurry_equation_1 (A : Type) (P : A -> Type) (B : Type)
  (f : forall a : A, P a -> B) (a : A) (b : P a) :
  sigT_uncurry f (existT P a b) = f a b.
Proof. reflexivity. Qed.

Hint Rewrite @sigT_uncurry_equation_1 : sigT_uncurry.

Corollary sigT_curry_dep_equation_1
  (A : Type) (P : A -> Type) (Q : forall a : A, P a -> Type)
  (f : forall x : {a : A & P a}, Q (projT1 x) (projT2 x))
  (a : A) (b : P a) : sigT_curry_dep f a b = f (existT P a b).
Proof. reflexivity. Qed.

Hint Rewrite @sigT_curry_dep_equation_1 : sigT_curry_dep.

Corollary sigT_uncurry_dep_equation_1
  (A : Type) (P : A -> Type) (Q : forall a : A, P a -> Type)
  (f : forall (a : A) (b : P a), Q a b) (a : A) (b : P a) :
  sigT_uncurry_dep f (existT P a b) = f a b.
Proof. reflexivity. Qed.

Hint Rewrite @sigT_uncurry_dep_equation_1 : sigT_uncurry_dep.

Corollary Ssig_curry_equation_1 (A : Type) (P : A -> SProp) (B : Type)
  (f : {a : A $ P a} -> B) (a : A) (b : P a) :
  Ssig_curry f a b = f (Sexists P a b).
Proof. reflexivity. Qed.

Hint Rewrite @Ssig_curry_equation_1 : Ssig_curry.

Corollary Ssig_uncurry_equation_1 (A : Type) (P : A -> SProp) (B : Type)
  (f : forall a : A, P a -> B) (a : A) (b : P a) :
  Ssig_uncurry f (Sexists P a b) = f a b.
Proof. reflexivity. Qed.

Hint Rewrite @Ssig_uncurry_equation_1 : Ssig_uncurry.

Corollary Ssig_curry_dep_equation_1
  (A : Type) (P : A -> SProp) (Q : forall a : A, P a -> Type)
  (f : forall x : {a : A $ P a}, Q (Spr1 x) (Spr2 x))
  (a : A) (b : P a) : Ssig_curry_dep f a b = f (Sexists P a b).
Proof. reflexivity. Qed.

Hint Rewrite @Ssig_curry_dep_equation_1 : Ssig_curry_dep.

Corollary Ssig_uncurry_dep_equation_1
  (A : Type) (P : A -> SProp) (Q : forall a : A, P a -> Type)
  (f : forall (a : A) (b : P a), Q a b) (a : A) (b : P a) :
  Ssig_uncurry_dep f (Sexists P a b) = f a b.
Proof. reflexivity. Qed.

Hint Rewrite @Ssig_uncurry_dep_equation_1 : Ssig_uncurry_dep.

Corollary compose_dep_equation_1
  (A : Type) (P : A -> Type) (Q : forall a : A, P a -> Type)
  (g : forall (a : A) (b : P a), Q a b) (f : forall a : A, P a)
  (a : A) : compose_dep g f a = g a (f a).
Proof. reflexivity. Qed.

Hint Rewrite @compose_dep_equation_1 : compose_dep.

Corollary const_dep_equation_1 (A : Type) (P : A -> Type) (a : A) (b : P a) :
  const_dep a b = a.
Proof. reflexivity. Qed.

Hint Rewrite @const_dep_equation_1 : const_dep.

Corollary flip_dep_equation_1 (A B : Type) (P : A -> B -> Type)
  (f : forall (a : A) (b : B), P a b) (b : B) (a : A) :
  flip_dep f b a = f a b.
Proof. reflexivity. Qed.

Hint Rewrite @flip_dep_equation_1 : flip_dep.

Corollary apply_dep_equation_1 (A : Type) (P : A -> Type)
  (f : forall a : A, P a) (a : A) :
  apply_dep f a = f a.
Proof. reflexivity. Qed.

Hint Rewrite @apply_dep_equation_1 : apply_dep.
