From Equations Require Import
  Equations.
From Coq Require Import
  Lia Lists.List NArith.NArith.
From Maniunfold.Has Require Export
  OneSorted.Decision.
From Maniunfold.Provides Require Export
  OptionTheorems PositiveTheorems ProductTheorems NTriangularNumbers.

Import ListNotations N.

Local Open Scope N_scope.

Set Equations Transparent.

Section Suffering.

(** These corollaries would be generated by [Equations] for [N.succ]. *)

Corollary succ_equation_1 : succ 0 = 1.
Proof. reflexivity. Qed.

Corollary succ_equation_2 (p : positive) : succ (Npos p) = Npos (Pos.succ p).
Proof. reflexivity. Qed.

Local Open Scope positive_scope.

Import Pos.

(** These corollaries would be generated by [Equations] for [Pos.shiftl]. *)

Corollary pos_shiftl_equation_1 (p : positive) : Pos.shiftl p 0 = p.
Proof. reflexivity. Qed.

Corollary pos_shiftl_equation_2 (p n0 : positive) :
  Pos.shiftl p (Npos n0) = Pos.iter xO p n0.
Proof. reflexivity. Qed.

(** These corollaries would be generated by [Equations] for [Pos.iter]. *)

Corollary pos_iter_equation_1 (A : Type) (f : A -> A) (x : A) (n' : positive) :
  iter f x (xI n') = f (iter f (iter f x n') n').
Proof. reflexivity. Qed.

Corollary pos_iter_equation_2 (A : Type) (f : A -> A) (x : A) (n' : positive) :
  iter f x (xO n') = iter f (iter f x n') n'.
Proof. reflexivity. Qed.

Corollary pos_iter_equation_3 (A : Type) (f : A -> A) (x : A) :
  iter f x xH = f x.
Proof. reflexivity. Qed.

(** These lemmas are missing from the standard library. *)

Lemma pos_shiftl_0_r (a : positive) : Pos.shiftl a 0 = a.
Proof. reflexivity. Qed.

Lemma pos_shiftl_succ_r' (a : positive) (b : N) :
  Pos.shiftl a (N.succ b) = xO (Pos.shiftl a b).
Proof.
  destruct b as [| p].
  - reflexivity.
  - rewrite succ_equation_2.
    rewrite pos_shiftl_equation_2.
    rewrite Pos.iter_succ.
    rewrite <- pos_shiftl_equation_2.
    reflexivity. Qed.

End Suffering.

(** Split the given positive number into a binary factor and an odd factor.

    See [pos_binfactor] and [pos_oddfactor] for details on the factors.
    This function is an inverse of [pos_binoddprod]. *)

Equations pos_binoddfactor (n : positive) : N * positive :=
  pos_binoddfactor (xI p) := (0, xI p);
  pos_binoddfactor (xO p) := let (b, c) := pos_binoddfactor p in (succ b, c);
  pos_binoddfactor xH := (0, xH).

(** Combine the given binary factor and odd factor into a positive number.

    This function is an inverse of [pos_binoddfactor]. *)

Equations pos_binoddprod (b : N) (c : positive) : positive :=
  pos_binoddprod b c := c * Pos.shiftl 1 b.

(** This function is a dependent version of [pos_binoddfactor]. *)

Equations pos_binoddfactor_dep (n : positive) :
  {x : N * positive $ Squash (pos_odd (snd x))} :=
  pos_binoddfactor_dep n := Sexists _ (pos_binoddfactor n) _.
Next Obligation.
  intros n.
  apply squash.
  induction n as [p ep | p ep |].
  - reflexivity.
  - rewrite pos_binoddfactor_equation_2.
    destruct (pos_binoddfactor p) as [b c].
    apply ep.
  - reflexivity. Qed.

(** This function is a dependent version of [pos_binoddprod]. *)

Equations pos_binoddprod_dep
  (b : N) (c : positive) (s : Squash (pos_odd c)) : positive :=
  pos_binoddprod_dep b c s := pos_binoddprod b c.

(** Find the binary factor of the given positive number.

    The factor is
    - the largest power of two to divide the given number and
    - the number of trailing zeros
      in the binary representation of the given number.
    This function generates the OEIS sequence A007814. *)

Equations pos_binfactor (n : positive) : N :=
  pos_binfactor n := fst (pos_binoddfactor n).

(** Find the odd factor of the given positive number.

    The factor is
    - the largest odd number to divide the given number and
    - whatever remains of the given number
      after removing trailing zeros from its binary representation.
    This function generates the OEIS sequence A000265. *)

Equations pos_oddfactor (n : positive) : positive :=
  pos_oddfactor n := snd (pos_binoddfactor n).

(** TODO An awkward lemma. *)

Lemma odd_pos_binoddfactor (c : positive) (e : pos_odd c) :
  pos_binoddfactor c = (0, c).
Proof.
  destruct c as [q | q |].
  - reflexivity.
  - inversion e.
  - reflexivity. Qed.

(** The function [pos_binoddprod] is an inverse of [pos_binoddfactor]. *)

Lemma pos_binoddprod_pos_binoddfactor (n : positive) :
  prod_uncurry pos_binoddprod (pos_binoddfactor n) = n.
Proof.
  destruct (pos_binoddfactor n) as [b c] eqn : e.
  cbv [prod_uncurry fst snd]. rewrite pos_binoddprod_equation_1.
  generalize dependent b. induction n as [p ep | p ep |]; intros b e.
  - rewrite pos_binoddfactor_equation_1 in e.
    injection e. clear e. intros ec eb. subst b c.
    rewrite pos_shiftl_0_r. rewrite Pos.mul_1_r.
    reflexivity.
  - rewrite pos_binoddfactor_equation_2 in e.
    destruct (pos_binoddfactor p) as [b' c'] eqn : e'.
    injection e. clear e. intros ec eb. subst b c.
    rewrite pos_shiftl_succ_r'. rewrite Pos.mul_xO_r.
    rewrite ep by reflexivity.
    reflexivity.
  - rewrite pos_binoddfactor_equation_3 in e.
    injection e. clear e. intros ec eb. subst b c.
    reflexivity. Qed.

(** The function [pos_binoddfactor] is not an inverse of [pos_binoddprod]. *)

Lemma not_pos_binoddfactor_pos_binoddprod : ~ forall (b : N) (c : positive),
  pos_binoddfactor (pos_binoddprod b c) = (b, c).
Proof. intros e. specialize (e 2%N 2%positive). cbv in e. inversion e. Qed.

(** The function [pos_binoddfactor] is an inverse of [pos_binoddprod]
    when the second factor is odd. *)

Lemma pos_binoddfactor_pos_binoddprod (b : N) (c : positive) (e : pos_odd c) :
  pos_binoddfactor (pos_binoddprod b c) = (b, c).
Proof.
  rewrite pos_binoddprod_equation_1.
  destruct b as [| p].
  - rewrite pos_shiftl_0_r. rewrite Pos.mul_1_r.
    rewrite odd_pos_binoddfactor by assumption.
    reflexivity.
  - induction p as [| q eq] using Pos.peano_ind.
    + rewrite pos_shiftl_equation_2. rewrite pos_iter_equation_3.
      rewrite (Pos.mul_comm c 2). change (2 * c)%positive with (xO c).
      rewrite pos_binoddfactor_equation_2.
      rewrite odd_pos_binoddfactor by assumption.
      reflexivity.
    + rewrite pos_shiftl_equation_2.
      rewrite Pos.iter_succ.
      rewrite <- pos_shiftl_equation_2.
      rewrite Pos.mul_xO_r.
      rewrite pos_binoddfactor_equation_2.
      rewrite eq by assumption.
      reflexivity. Qed.

(** The function [pos_binoddprod_dep] is an inverse
    of [pos_binoddfactor_dep]. *)

Lemma pos_binoddprod_dep_pos_binoddfactor_dep (n : positive) :
  Ssig_uncurry (prod_uncurry_dep pos_binoddprod_dep)
  (pos_binoddfactor_dep n) = n.
Proof. apply pos_binoddprod_pos_binoddfactor. Qed.

(** The function [pos_binoddfactor_dep] is an inverse
    of [pos_binoddprod_dep]. *)

Lemma pos_binoddfactor_dep_pos_binoddprod_dep
  (b : N) (c : positive) (s : Squash (pos_odd c)) :
  pos_binoddfactor_dep (pos_binoddprod_dep b c s) = Sexists _ (b, c) s.
Proof.
  rewrite pos_binoddprod_dep_equation_1.
  rewrite pos_binoddfactor_dep_equation_1.
  apply Spr1_inj. cbv [Spr1].
  apply pos_binoddfactor_pos_binoddprod.
  (** TODO Instances! *)
  assert (HasDec (pos_odd c)).
  { hnf. cbv [pos_odd negb pos_even]. destruct c. all: intuition. }
  apply unsquash in s. auto. Qed.

(** Split the given natural number into a binary factor and an odd factor,
    except for the degenerate case at zero.

    See [pos_binoddfactor] for details on this function. *)

Equations binoddfactor (n : N) : N * N :=
  binoddfactor N0 := (0, 0);
  binoddfactor (Npos p) := let (b, c) := pos_binoddfactor p in (b, Npos c).

(** Combine the given binary factor and odd factor into a natural number,
    except for the degenerate case at zero.

    See [pos_binoddprod] for details on this function. *)

Equations binoddprod (b c : N) : N :=
  binoddprod b N0 := 0;
  binoddprod b (Npos p) := Npos (pos_binoddprod b p).

(** The function [binoddprod] has an arithmetic form. *)

Lemma binoddprod_eqn (b c : N) : binoddprod b c = c * 2 ^ b.
Proof.
  destruct c as [| p].
  - reflexivity.
  - rewrite binoddprod_equation_2.
    rewrite pos_binoddprod_equation_1.
    rewrite <- shiftl_1_l.
    reflexivity. Qed.

(** Find the binary factor of the given positive number.
    except for the degenerate case at zero.

    See [pos_binfactor] for details on this function. *)

Equations binfactor (n : N) : N :=
  binfactor n := fst (binoddfactor n).

(** Find the odd factor of the given positive number.
    except for the degenerate case at zero.

    See [pos_oddfactor] for details on this function. *)

Equations oddfactor (n : N) : N :=
  oddfactor n := snd (binoddfactor n).

(** The function [binoddprod] is an inverse of [binoddfactor]. *)

Lemma binoddprod_binoddfactor (n : N) :
  prod_uncurry binoddprod (binoddfactor n) = n.
Proof.
  destruct n as [| p].
  - reflexivity.
  - pose proof pos_binoddprod_pos_binoddfactor p as e.
    rewrite binoddfactor_equation_2.
    destruct (pos_binoddfactor p) as [b c].
    cbv [prod_uncurry fst snd]. rewrite binoddprod_equation_2.
    cbv [prod_uncurry fst snd] in e.
    rewrite e.
    reflexivity. Qed.

(** The function [binoddfactor] is not an inverse of [binoddprod]. *)

Lemma not_binoddfactor_binoddprod : ~ forall b c : N,
  binoddfactor (binoddprod b c) = (b, c).
Proof.
  intros e.
  apply not_pos_binoddfactor_pos_binoddprod.
  intros b c.
  specialize (e b (Npos c)).
  rewrite binoddprod_equation_2 in e. rewrite binoddfactor_equation_2 in e.
  destruct (pos_binoddfactor (pos_binoddprod b c)) as [b' c'].
  injection e. clear e. intros ec eb. subst b c.
  reflexivity. Qed.

(** The function [binoddfactor] is an inverse of [binoddprod]
    when the second factor is odd. *)

Lemma odd_binoddfactor_binoddprod (b c : N) (e : odd c) :
  binoddfactor (binoddprod b c) = (b, c).
Proof.
  destruct b as [| p], c as [| q].
  - reflexivity.
  - rewrite binoddprod_eqn.
    rewrite pow_0_r. rewrite mul_1_r.
    rewrite binoddfactor_equation_2.
    rewrite odd_pos_binoddfactor by assumption.
    reflexivity.
  - inversion e.
  - rewrite binoddprod_eqn.
    change (Npos q * 2 ^ Npos p) with (Npos (q * 2 ^ p)).
    rewrite binoddfactor_equation_2.
    change (q * 2 ^ p)%positive with (pos_binoddprod (Npos p) q).
    rewrite pos_binoddfactor_pos_binoddprod by assumption.
    reflexivity. Qed.

Module Cantor.

Definition pair_shell (n : N) : N := untri n.

Arguments pair_shell _ : assert.

Definition unpair_shell (p q : N) : N := q + p.

Arguments unpair_shell _ _ : assert.

Definition pair (n : N) : N * N :=
  let (u, v) := untri_rem n in
  (u - v, v).

Arguments pair _ : assert.

Definition unpair (p q : N) : N := q + tri (unpair_shell p q).

Arguments unpair _ _ : assert.

Compute map pair (seq 0 64).
Compute map (prod_uncurry unpair o pair) (seq 0 64).

Compute map pair_shell (seq 0 64).
Compute map (prod_uncurry unpair_shell o pair) (seq 0 64).

(** Just to see if it can be done. *)

Definition pair_shell_rem (n : N) : N * N := untri_rem n.

Arguments pair_shell_rem _ : assert.

Import Program.Wf.

Definition counpair_shell (p q : N) : N := q + tri p.

Definition shell_size (i : N) : N :=
  counpair_shell (1 + i) 0 - counpair_shell i 0.

Definition shell_wf (i j : N) : Prop := j < shell_size i.

Definition shell_codom : Type :=
  {x : N * N $ Squash (prod_uncurry shell_wf x)}.

(** This shall now be a bijection proper. *)

Program Definition pair_shell' (n : N) : shell_codom :=
  Sexists _ (pair_shell_rem n) _.
Next Obligation.
  intros n. apply squash.
  cbv [prod_uncurry fst snd shell_wf pair_shell_rem shell_size counpair_shell].
  destruct (untri_rem n) as [p q] eqn : e.
  rewrite tri_succ.
  enough (q < 1 + p) by lia.
  rewrite untri_rem_tri_untri in e.
  injection e. clear e. intros eq ep. subst q p.
  pose proof tri_untri_untri_rem n as l. lia. Qed.

Theorem unpair_shell_pair (n : N) :
  prod_uncurry unpair_shell (pair n) = pair_shell n.
Proof.
  cbv [prod_uncurry fst snd unpair_shell pair pair_shell].
  rewrite untri_rem_tri_untri.
  pose proof tri_untri_untri_rem n as l.
  remember (n - tri (untri n)) as p eqn : ep.
  replace (untri n - p + p) with (untri n) by lia. lia. Qed.

Theorem pair_shell_unpair (p q : N) :
  pair_shell (unpair p q) = unpair_shell p q.
Proof.
  cbv [pair_shell unpair unpair_shell].
  replace (q + p) with (p + q) by lia.
  rewrite tri_what. lia. Qed.

Theorem unpair_pair (n : N) : prod_uncurry unpair (pair n) = n.
Proof.
  cbv [prod_uncurry fst snd unpair unpair_shell pair].
  rewrite untri_rem_tri_untri.
  pose proof tri_untri n as l.
  pose proof tri_untri_untri_rem n as l'.
  remember (n - tri (untri n)) as p eqn : ep.
  replace (p + (untri n - p)) with (untri n) by lia. lia. Qed.

Theorem pair_unpair (p q : N) : pair (unpair p q) = (p, q).
Proof.
  cbv [pair unpair unpair_shell].
  rewrite untri_rem_tri_untri. f_equal.
  - replace (q + p) with (p + q) by lia. rewrite tri_what. lia.
  - replace (q + p) with (p + q) by lia. rewrite tri_what. lia. Qed.

End Cantor.

Module RosenbergStrong.

Definition pair_shell (n : N) : N := sqrt n.

Arguments pair_shell _ : assert.

(* Definition z (x : N) : N := 1 + 2 * x.
Definition sum_z (x : N) : N := x ^ 2.
Compute map z (seq 0 32).
Compute map sum_z (seq 0 32).
Compute map (fun x : N => (z x, sum_z (1 + x) - sum_z x)) (seq 0 32).
Program Fixpoint s (tot ix : N) (x : N) {measure (N.to_nat x)} : N * N :=
  if x <? z ix + tot then (ix, x - tot) else s (z ix + tot) (1 + ix) x.
Next Obligation. Admitted.
Next Obligation. Tactics.program_solve_wf. Defined.
Compute map (s 0 0) (seq 0 32).
Compute map sqrtrem (seq 0 32). *)

Definition unpair_shell (p q : N) : N := max q p.

Arguments unpair_shell _ _ : assert.

Definition pair (n : N) : N * N :=
  let (s, t) := sqrtrem n in
  if s <=? t then (s - (t - s), s) else (s, t).

Arguments pair _ : assert.

Definition unpair (p q : N) : N :=
  if p <=? q then (q - p) + q * (1 + q) else q + p * p.

Arguments unpair _ _ : assert.

Theorem unpair_shell_pair (n : N) :
  prod_uncurry unpair_shell (pair n) = pair_shell n.
Proof.
  cbv [prod_uncurry fst snd unpair_shell pair pair_shell].
  rewrite <- sqrtrem_sqrt. cbv [fst snd].
  destruct_sqrtrem s t est es e0st l1st.
  clear est es.
  destruct (leb_spec s t) as [lst | lst]; lia. Qed.

Theorem pair_shell_unpair (p q : N) :
  pair_shell (unpair p q) = unpair_shell p q.
Proof.
  cbv [pair_shell unpair unpair_shell].
  rewrite <- sqrtrem_sqrt. cbv [fst snd].
  destruct_sqrtrem s t est es e0st l1st.
  clear est es.
  destruct (leb_spec p q) as [lpq | lpq]; nia. Qed.

Theorem unpair_pair (n : N) : prod_uncurry unpair (pair n) = n.
Proof.
  cbv [prod_uncurry fst snd unpair pair].
  destruct_sqrtrem s t est es e0st l1st.
  clear est es.
  destruct (leb_spec s t) as [lst | lst].
  - destruct (leb_spec (s - (t - s)) s) as [lst' | lst']; lia.
  - destruct (leb_spec s t) as [lst' | lst']; lia. Qed.

Theorem pair_unpair (p q : N) : pair (unpair p q) = (p, q).
Proof.
  cbv [pair unpair].
  destruct_sqrtrem s t est es e0st l1st.
  clear est es.
  destruct (leb_spec s t) as [lst | lst].
  - destruct (leb_spec p q) as [lpq | lpq].
    + assert (e : s = q) by nia. subst s. f_equal; nia.
    + assert (f : s <> q) by nia. exfalso.
      assert (l : p <= s) by nia. nia.
  - destruct (leb_spec p q) as [lpq | lpq].
    + assert (f : s <> p) by nia. exfalso.
      assert (l : q < s) by nia. nia.
    + assert (e : s = p) by nia. subst s. f_equal; nia. Qed.

End RosenbergStrong.

Module Szudzik.

Definition pair_shell (n : N) : N := sqrt n.

Arguments pair_shell _ : assert.

Definition unpair_shell (p q : N) : N := max q p.

Arguments unpair_shell _ _ : assert.

Definition pair (n : N) : N * N :=
  let (s, t) := sqrtrem n in
  if s <=? t then (t - s, s) else (s, t).

Arguments pair _ : assert.

Definition unpair (p q : N) : N :=
  if p <=? q then p + q * (1 + q) else q + p * p.

Arguments unpair _ _ : assert.

(** Note how the three following proofs are
    nearly exactly the same as in [RosenbergStrong]. *)

Theorem unpair_shell_pair (n : N) :
  prod_uncurry unpair_shell (pair n) = pair_shell n.
Proof.
  cbv [prod_uncurry fst snd unpair_shell pair pair_shell].
  rewrite <- sqrtrem_sqrt. cbv [fst snd].
  destruct_sqrtrem s t est es e0st l1st.
  clear est es.
  destruct (leb_spec s t) as [lst | lst]; lia. Qed.

Theorem pair_shell_unpair (p q : N) :
  pair_shell (unpair p q) = unpair_shell p q.
Proof.
  cbv [pair_shell unpair unpair_shell].
  rewrite <- sqrtrem_sqrt. cbv [fst snd].
  destruct_sqrtrem s t est es e0st l1st.
  clear est es.
  destruct (leb_spec p q) as [lpq | lpq]; nia. Qed.

Theorem unpair_pair (n : N) : prod_uncurry unpair (pair n) = n.
Proof.
  cbv [prod_uncurry fst snd unpair pair].
  destruct_sqrtrem s t est es e0st l1st.
  clear est es.
  destruct (leb_spec s t) as [lst | lst].
  - destruct (leb_spec (t - s) s) as [lst' | lst']; lia.
  - destruct (leb_spec s t) as [lst' | lst']; lia. Qed.

Theorem pair_unpair (p q : N) : pair (unpair p q) = (p, q).
Proof.
  cbv [pair unpair].
  destruct_sqrtrem s t est es e0st l1st.
  clear est es.
  destruct (leb_spec s t) as [lst | lst].
  - destruct (leb_spec p q) as [lpq | lpq].
    + assert (e : s = q) by nia. subst s. f_equal; nia.
    + assert (f : s <> q) by nia. exfalso.
      assert (l : p <= s) by nia. nia.
  - destruct (leb_spec p q) as [lpq | lpq].
    + assert (f : s <> p) by nia. exfalso.
      assert (l : q < s) by nia. nia.
    + assert (e : s = p) by nia. subst s. f_equal; nia. Qed.

End Szudzik.

#[ugly]
Module Hausdorff.

Lemma pos_binfactor_even (n : positive) :
  pos_binfactor (2 * n) = 1 + pos_binfactor n.
Proof.
  induction n as [p ei | p ei |].
  - reflexivity.
  - cbn [pos_binfactor].
    replace (1 + succ (pos_binfactor p)) with (succ (1 + pos_binfactor p)) by lia.
    rewrite <- ei. reflexivity.
  - reflexivity. Qed.

Lemma pos_binfactor_even_succ (n : positive) :
  pos_binfactor (succ_pos (2 * Npos n - 1)) = 1 + pos_binfactor n.
Proof.
  induction n as [p ei | p ei |].
  - reflexivity.
  - cbn [pos_binfactor].
    replace (1 + succ (pos_binfactor p)) with (succ (1 + pos_binfactor p)) by lia.
    rewrite <- ei. reflexivity.
  - reflexivity. Qed.

Lemma part_factor (n : N) (f : n <> 0) :
  exists p q : N, n = (1 + 2 * q) * 2 ^ p.
Proof.
  destruct n as [| p].
  - contradiction.
  - exists (pos_binfactor p), ((pos_oddfactor p - 1) / 2). clear f.
    induction p as [q ei | q ei |].
    + cbn [pos_binfactor pos_oddfactor]. rewrite pow_0_r. rewrite mul_1_r.
      rewrite <- divide_div_mul_exact. rewrite (mul_comm 2 _). rewrite div_mul.
      lia. lia. lia. cbn. replace (q~0)%positive with (2 * q)%positive by lia.
      replace (pos (2 * q)%positive) with (2 * Npos q) by lia.
      apply divide_factor_l.
    + cbn [pos_binfactor pos_oddfactor]. rewrite pow_succ_r by lia.
      rewrite mul_assoc. lia.
    + reflexivity. Qed.

Lemma part_factor_again (p q : N) :
  exists n : N, n = (1 + 2 * q) * 2 ^ p.
Proof. exists ((1 + 2 * q) * 2 ^ p). reflexivity. Qed.

Lemma part_urgh (n : positive) :
  let p := pos_binfactor n in
  let q := (pos_oddfactor n - 1) / 2 in
  Npos n = (1 + 2 * q) * 2 ^ p.
Proof.
  intros p' q'. subst p' q'.
  induction n as [q ei | q ei |].
  + cbn [pos_binfactor pos_oddfactor]. rewrite pow_0_r. rewrite mul_1_r.
    rewrite <- divide_div_mul_exact. rewrite (mul_comm 2 _). rewrite div_mul.
    lia. lia. lia. cbn. replace (q~0)%positive with (2 * q)%positive by lia.
    replace (pos (2 * q)%positive) with (2 * Npos q) by lia.
    apply divide_factor_l.
  + cbn [pos_binfactor pos_oddfactor]. rewrite pow_succ_r by lia.
    rewrite mul_assoc. lia.
  + reflexivity. Qed.

Lemma binfactor_odd (n : N) : binfactor (1 + 2 * n) = 0.
Proof.
  destruct n as [| p].
  - arithmetize. reflexivity.
  - induction p as [q ei | q ei |].
    + reflexivity.
    + reflexivity.
    + reflexivity. Qed.

Lemma binfactor_even (n : N) (f : n <> 0) :
  binfactor (2 * n) = 1 + binfactor n.
Proof.
  destruct n as [| p].
  - arithmetize. cbn. lia.
  - apply (pos_binfactor_even p). Qed.

Lemma binfactor_pow_2 (n p : N) (f : p <> 0) :
  binfactor (2 ^ n * p) = n + binfactor p.
Proof.
  destruct n as [| q].
  - arithmetize. reflexivity.
  - generalize dependent p. induction q as [r ei | r ei |]; intros p f.
    + replace (pos r~1) with (succ (2 * pos r)) by lia.
      rewrite pow_succ_r'.
      rewrite <- mul_assoc.
      rewrite binfactor_even.
      replace (2 * pos r) with (pos r + pos r) by lia.
      rewrite pow_add_r.
      rewrite <- mul_assoc.
      rewrite ei.
      rewrite ei. lia. lia.
      specialize (ei p).
      destruct p. lia.
      pose proof pow_nonzero 2 (pos r).
      lia.
      pose proof pow_nonzero 2 (2 * pos r).
      lia.
    + replace (pos r~0) with (2 * pos r) by lia.
      replace (2 * pos r) with (pos r + pos r) by lia.
      rewrite pow_add_r.
      rewrite <- mul_assoc.
      rewrite ei.
      rewrite ei. lia.
      lia.
      pose proof pow_nonzero 2 (pos r).
      lia.
    + arithmetize.
      destruct p. lia.
      rewrite binfactor_even.
      lia. lia. Qed.

Lemma binfactor_trivial (p q : N) :
  binfactor ((1 + 2 * q) * 2 ^ p) = p.
Proof.
  destruct p as [| r].
  - arithmetize. apply binfactor_odd.
  - generalize dependent q. induction r as [s ei | s ei |]; intros q.
    + replace (pos s~1) with (succ (2 * pos s)) by lia.
      rewrite pow_succ_r'.
      replace (2 * pos s) with (pos s + pos s) by lia.
      rewrite pow_add_r.
      rewrite mul_shuffle3.
      rewrite binfactor_even.
      rewrite mul_shuffle3.
      rewrite binfactor_pow_2.
      rewrite ei. lia.
      pose proof pow_nonzero 2 (pos s).
      lia.
      pose proof pow_nonzero 2 (pos s).
      lia.
    + replace (pos s~0) with (2 * pos s) by lia.
      replace (2 * pos s) with (pos s + pos s) by lia.
      rewrite pow_add_r.
      rewrite mul_shuffle3.
      rewrite binfactor_pow_2.
      rewrite ei. lia.
      pose proof pow_nonzero 2 (pos s).
      lia.
    + arithmetize.
      rewrite binfactor_even.
      rewrite binfactor_odd.
      lia. lia. Qed.

Lemma pos_binfactor_trivial (p q : N) :
  pos_binfactor (succ_pos ((1 + 2 * q) * 2 ^ p - 1)) = p.
Proof.
  pose proof binfactor_trivial p q as e.
  remember ((1 + 2 * q) * 2 ^ p) as r eqn : er.
  destruct r as [| s].
  - arithmetize. cbn. rewrite <- e. reflexivity.
  - replace (succ_pos (Npos s - 1)) with s. rewrite <- e. reflexivity.
    induction s.
    reflexivity.
    cbn. rewrite Pos.pred_double_spec. rewrite Pos.succ_pred; lia.
    reflexivity. Qed.

Lemma oddfactor_odd (n : N) : oddfactor (1 + 2 * n) = 1 + 2 * n.
Proof.
  destruct n as [| p].
  - arithmetize. reflexivity.
  - induction p as [q ei | q ei |].
    + reflexivity.
    + reflexivity.
    + reflexivity. Qed.

Lemma oddfactor_even (n : N) :
  oddfactor (2 * n) = oddfactor n.
Proof.
  destruct n as [| p].
  - arithmetize. cbn. lia.
  - reflexivity. Qed.

Lemma oddfactor_pow_2 (n p : N) (f : p <> 0) :
  oddfactor (2 ^ n * p) = oddfactor p.
Proof.
  destruct n as [| q].
  - arithmetize. cbn. lia.
  - generalize dependent p. induction q as [s ei | s ei |]; intros p f.
    + replace (pos s~1) with (succ (2 * pos s)) by lia.
      rewrite pow_succ_r'.
      replace (2 * pos s) with (pos s + pos s) by lia.
      rewrite pow_add_r.
      rewrite <- mul_assoc.
      rewrite oddfactor_even.
      rewrite <- mul_assoc.
      rewrite ei.
      rewrite ei.
      lia.
      lia.
      pose proof pow_nonzero 2 (pos s).
      lia.
    + replace (pos s~0) with (2 * pos s) by lia.
      replace (2 * pos s) with (pos s + pos s) by lia.
      rewrite pow_add_r.
      rewrite <- mul_assoc.
      rewrite ei.
      rewrite ei.
      lia.
      lia.
      pose proof pow_nonzero 2 (pos s).
      lia.
    + arithmetize.
      rewrite oddfactor_even.
      lia. Qed.

Lemma oddfactor_trivial (p q : N) :
  oddfactor ((1 + 2 * q) * 2 ^ p) = 1 + 2 * q.
Proof.
  destruct p as [| r].
  - arithmetize. apply oddfactor_odd.
  - generalize dependent q. induction r as [s ei | s ei |]; intros q.
    + replace (pos s~1) with (succ (2 * pos s)) by lia.
      rewrite pow_succ_r'.
      replace (2 * pos s) with (pos s + pos s) by lia.
      rewrite pow_add_r.
      rewrite mul_shuffle3.
      rewrite oddfactor_even.
      rewrite mul_shuffle3.
      rewrite oddfactor_pow_2.
      rewrite ei. lia.
      pose proof pow_nonzero 2 (pos s).
      lia.
    + replace (pos s~0) with (2 * pos s) by lia.
      replace (2 * pos s) with (pos s + pos s) by lia.
      rewrite pow_add_r.
      rewrite mul_shuffle3.
      rewrite oddfactor_pow_2.
      rewrite ei. lia.
      pose proof pow_nonzero 2 (pos s).
      lia.
    + arithmetize.
      rewrite oddfactor_even.
      rewrite oddfactor_odd.
      lia. Qed.

Lemma pos_oddfactor_trivial (p q : N) :
  pos_oddfactor (succ_pos ((1 + 2 * q) * 2 ^ p - 1)) = 1 + 2 * q.
Proof.
  pose proof oddfactor_trivial p q as e.
  remember ((1 + 2 * q) * 2 ^ p) as r eqn : er.
  destruct r as [| s].
  - arithmetize. rewrite <- e. cbn. pose proof pow_nonzero 2 p. lia.
  - replace (succ_pos (Npos s - 1)) with s. rewrite <- e. reflexivity.
    induction s.
    reflexivity.
    cbn. rewrite Pos.pred_double_spec. rewrite Pos.succ_pred; lia.
    reflexivity. Qed.

Local Lemma logging (n : positive) : pos_log2 n = log2 (Npos n).
Proof.
  induction n; cbn.
  rewrite IHn; destruct n; reflexivity.
  rewrite IHn; destruct n; reflexivity.
  reflexivity. Qed.

Definition pair_shell (n : N) : N :=
  pos_log2 (succ_pos n).

Arguments pair_shell _ : assert.

Lemma pair_shell_eqn (n : N) : pair_shell n =
  log2 (1 + n).
Proof.
  cbv [pair_shell]. rewrite logging.
  rewrite succ_pos_spec. rewrite add_1_l. reflexivity. Qed.

Definition unpair_shell (p q : N) : N := p + pos_log2 (succ_pos (shiftl q 1)).

Arguments unpair_shell _ _ : assert.

Lemma unpair_shell_eqn (p q : N) : unpair_shell p q =
  log2 (binoddprod p (1 + 2 * q)).
Proof. cbv [unpair_shell]. arithmetize. Admitted.

Definition pair (n : N) : N * N :=
  let (p, q) := binoddfactor (succ n) in
  (p, shiftr (pred q) 1).
  (* (pos_binfactor (succ_pos n), shiftr (pred (pos_oddfactor (succ_pos n))) 1). *)

Arguments pair _ : assert.

Lemma pair_eqn (n : N) : pair n =
  (pos_binfactor (succ_pos n), (pos_oddfactor (succ_pos n) - 1) / 2).
Proof. Admitted.

Definition unpair (p q : N) : N := pred (binoddprod p (succ (shiftl q 1))).

Arguments unpair _ _ : assert.

Lemma unpair_eqn (p q : N) : unpair p q =
  (1 + 2 * q) * 2 ^ p - 1.
Proof. cbv [unpair]. rewrite binoddprod_eqn. arithmetize. reflexivity. Qed.

Compute map pair (seq 0 64).
Compute map (prod_uncurry unpair o pair) (seq 0 64).

Compute map pair_shell (seq 0 64).
Compute map (prod_uncurry unpair_shell o pair) (seq 0 64).

Theorem unpair_shell_pair (n : N) :
  prod_uncurry unpair_shell (pair n) = pair_shell n.
Proof.
  cbv [prod_uncurry fst snd unpair_shell pair pair_shell]. Admitted.

Theorem pair_shell_unpair (p q : N) :
  pair_shell (unpair p q) = unpair_shell p q.
Proof.
  cbv [pair_shell unpair unpair_shell]. Admitted.

Theorem unpair_pair (n : N) : prod_uncurry unpair (pair n) = n.
Proof.
  cbv [prod_uncurry]. rewrite unpair_eqn. rewrite pair_eqn. cbv [fst snd].
  destruct (eqb_spec n 0) as [e | f].
  - subst n. reflexivity.
  - pose proof (part_urgh (succ_pos n)) as e.
    rewrite <- e. rewrite succ_pos_spec. lia. Qed.

Theorem pair_unpair (p q : N) : pair (unpair p q) = (p, q).
Proof.
  cbv [prod_uncurry]. rewrite pair_eqn. rewrite unpair_eqn.
  f_equal.
  - rewrite pos_binfactor_trivial. reflexivity.
  - rewrite pos_oddfactor_trivial.
    replace (1 + 2 * q - 1) with (2 * q) by lia.
    rewrite div_Even. reflexivity. Qed.

End Hausdorff.
